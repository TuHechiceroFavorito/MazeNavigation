{"mode":"Text","textContent":"# --------------------------------------------------------------------------------------------------------------------\n#\n#   Project:      Maze navigation and mapping\n#   Authors:      Evanna Niall and Daniel Ãlvarez CarreÃ±o\n#   Created:      24/2/2021\n#   Description:  The robot is able to navigate through a maze, map it and find the quickest path\n#\n#   Note on the code: We have noticed that at start VEXcode throughs a wait error. It asks to add a wait statement\n#   in a loop. We have noticed that this error is solved if the dialog is ignored and the â­¯ symbol is pressed.\n#   We think it might be because of the loading of the code\n#\n# --------------------------------------------------------------------------------------------------------------------\n# Library imports\nfrom vexcode import *\nimport copy\n#List of all known tiles. It's global to make editing and reading easier.\ntiles_list = []\n#Solved solutions for starting and robot. List of paths that are too long\nstarting = []\nrobot = []\npaths = []\n#This are the coordinates of the corners of the tiles\nforbidden_areas = []\n\n#Rough width of a tile, coordinates of the first left lower corner and width of a wall\ntile = 230\norigin = -990\nwall = 15\ncount_distance_starting=0\ncount_distance_robot=0\n\n#This function is from assignment 2 topic 3. The formula has been adjusted to the length of 250mm of\n#the squares of this playground. More detailed explanation above function mad_eye_strategy\n\n#Initialise the tiles. Fills the list tiles_list with an 8x8 matrix. Each cell represents a tile\n#of the maze. For each tile it is stored the walls following a compass system:\n#[N, E, S, W]. 1 for a wall, 0 for no wall and u for unkown. It is also stored the number of tiles\n#that the robot has been in the tile.\ndef init_tiles():\n    global tiles_list\n    tiles = tiles_list\n    for i in range (8):     #Tens\n        tiles.append([])\n        for j in range(8):  #Units\n            tiles[i].append([['u', 'u', 'u', 'u'], 0])\n    \n    #Set to 1 the known walls on the sides of the maze\n    for i in range(8):\n        tiles[0][i] = [['u', 'u', 1, 'u'], 0]\n        tiles[i][0] = [['u', 'u', 'u', 1], 0]\n        tiles[7][i] = [[1, 'u', 'u', 'u'], 0]\n        tiles[i][7] = [['u', 1, 'u', 'u'], 0]\n    tiles[0][0] = [['u', 'u', 1, 1], 0]\n    tiles[7][0] = [[1, 'u', 'u', 1], 0]\n    tiles[7][7] = [[1, 1, 'u', 'u'], 0]\n    tiles[0][7] = [['u', 1, 1, 'u'], 0]\n\n#Returns the number of a tile given its coordinates.\n#The maze it's divided into 8 rows and 8 columns of tiles. The number of the tiles\n#increases by 1 in the positive direction of the x axis and increases by 10 in the\n#positive direction of the y axis.   \ndef num_predictor(x, y):\n    global origin\n    global tile\n\n    a = int((y - origin) / (tile + wall))\n    #Due to imprecisions in the measurements, on the first row and last column it gets the number wrong by 1\n    #So a correction is needed\n    if a > 7:\n        a = 7\n    b = int((x - origin) / (tile + wall))\n    if b > 7:\n        b = 7\n\n    num = (a*10 + b)\n    return num\n\n#Sets the adjacent wall to the required value. If no orientation for the wall is passed,\n#the function takes the value from the position of the robot. target specifies at which list\n#is the adjacent filler applied\ndef adjacent_filler(tile_num, value, orientation=False, target='tiles'):\n    if target == 'start':\n        global starting\n        tiles = starting\n    elif target == 'robot':\n        global robot\n        tiles = robot\n    else:\n        global tiles_list\n        tiles = tiles_list\n        \n    #Set the appropriate adjacent tile and the wall index\n    #Also make sure not to select a tile that is out of the maze (keep track of corners)\n    if orientation is False:\n        if drivetrain.heading(DEGREES) == 0 and tile_num<70:        #N\n            adj_tile = tile_num+10\n            adj_wall = 2\n        elif drivetrain.heading(DEGREES) == 90 and tile_num%10<7:     #E\n            adj_tile = tile_num+1\n            adj_wall = 3\n        elif drivetrain.heading(DEGREES) == 180 and tile_num>10:    #S\n            adj_tile = tile_num-10\n            adj_wall = 0\n        elif drivetrain.heading(DEGREES) == 270 and tile_num%10>0:    #W\n            adj_tile = tile_num-1\n            adj_wall = 1\n        else:           #No adjacent tile. The robot is in a corner\n            adj_tile = None\n\n    else:\n        if orientation == 0 and tile_num<70:        #N\n            adj_tile = tile_num+10\n            adj_wall = 2\n        elif orientation == 1 and tile_num%10<7:     #E\n            adj_tile = tile_num+1\n            adj_wall = 3\n        elif orientation == 2 and tile_num>=10:    #S\n            adj_tile = tile_num-10\n            adj_wall = 0\n        elif orientation == 3 and tile_num%10>0:    #W\n            adj_tile = tile_num-1\n            adj_wall = 1\n        else:           #No adjacent tile. The robot is in a corner\n            adj_tile = None\n    #Do only if there is an adjacent tile\n    if adj_tile != None:\n        tiles[int(adj_tile/10)][adj_tile % 10][0][adj_wall] = value   #Set the appropriate wall to its neighbor value\n\n#This function adds the information of the wall right in front\ndef wall_mapping():\n    global tiles_list\n    tiles = tiles_list\n    tile_num = num_predictor(location.position(X, MM), location.position(Y, MM))  #Number of the current tile\n    current_tile = []\n        #Check if the nearest wall is in the current tile\n    if distance.get_distance(MM) > 250 and distance.get_distance(MM) < 3000:\n        tiles_ahead = int(distance.get_distance(MM)/250)        #How many tiles ahead it is\n        #Set the correct values for the tile number and orientation\n        if drivetrain.heading(DEGREES) == 0:\n            distant_tile = tile_num+10*tiles_ahead\n            orientation = 0\n        elif drivetrain.heading(DEGREES) == 90:\n            distant_tile = tile_num+tiles_ahead\n            orientation = 1\n        elif drivetrain.heading(DEGREES) == 180:\n            distant_tile = tile_num-10*tiles_ahead\n            orientation = 2\n        elif drivetrain.heading(DEGREES) == 270:\n            distant_tile = tile_num-tiles_ahead\n            orientation = 3\n        #Loop though all the middle values in between the current tile and the distant one\n        for middle in range(tiles_ahead + 1):   #+1 to include the distant_tile and the current one\n            #Change the tile number according to the orientation and the current middle value\n            #Working from distant tile to current one\n            if orientation == 1:\n                target = distant_tile - middle\n            elif orientation == 2:\n                target = distant_tile + 10*middle\n            elif orientation == 3:\n                target = distant_tile + middle\n            elif orientation == 0:\n                target = distant_tile - 10*middle\n    \n            tiles[int(target/10)][target % 10][0][orientation] = 0   #Set the appropriate wall\n            #Fill adjacent tile\n            adjacent_filler(target, 0)\n        #Change the working tile to the distant one to assign it the value 1\n        tile_num = distant_tile\n    elif distance.get_distance(MM) >= 3000:     #It is facing to the void (the starting or the ending tiles)\n        if drivetrain.heading(DEGREES) == 0:    #North\n            tile_num = 73\n        elif drivetrain.heading(DEGREES) == 180: #South\n            tile_num = 4\n        \n    #Select the walls of the tile\n    walls = tiles[int(tile_num/10)][tile_num % 10][0]\n    #Detect the orientation of the wall in the tile\n    if drivetrain.heading(DEGREES) == 0:    #North\n        walls[0] = 1\n    elif drivetrain.heading(DEGREES) == 90:  #East\n        walls[1] = 1\n    elif drivetrain.heading(DEGREES) == 180: #South\n        walls[2] = 1\n    elif drivetrain.heading(DEGREES) == 270: #West\n        walls[3] = 1\n    #Fill adjacent tile\n    adjacent_filler(tile_num, 1)\n\n    #Clear the output and display the map\n    brain.clear()\n    display_map()\n\n#Follow the left wall until it has scanned all the walls on the maze \ndef mad_eye_strategy(cup=False):\n    global tiles_list\n    tiles = tiles_list\n    global starting\n    global robot\n    \n    discovered = False\n    while discovered == False:\n        wait(5, MSEC)\n        check_wall_on_left()\n        if cup is not True:\n            discovered = True\n            #Check if there is any wall left to scan\n            for row in tiles:\n                for tile in row:\n                    for wall in tile[0]:\n                        if wall == 'u':\n                            discovered = False\n        else:\n            tile = num_predictor(location.position(X, MM), location.position(Y, MM))    #Get the current tile\n            if tile == cup:\n                break\n    \n    #The maze is fully scan. Copy the data into both lists to solve the maze from there\n    starting = copy.deepcopy(tiles)\n    robot = copy.deepcopy(tiles)\n\n#Same as mad_eye_strategy, but it doesn't scan. It only follows the left wall, but as everything\n#is closed except the solution, it will drive to it.\ndef beat_it():\n    pen.set_pen_color(RED)\n    while True:\n        wait(5, MSEC)\n        check_wall_on_left(False, 'robot')\n        tile = num_predictor(location.position(X, MM), location.position(Y, MM))    #Get the current tile\n        if tile == 73:\n            break\n\n\n#Rotates the frame of reference of the robot. Returns the appropriate indeces for this rotation\ndef frame(orientation=False):\n    #It takes the direction of the robot\n    if orientation is False:\n        orientation = drivetrain.heading(DEGREES)\n    \n    #If the robot is facing North \n    if orientation==0:\n        N=0\n        E=1\n        S=2\n        W=3\n    #If the robot is facing East\n    if orientation==90:\n        N=1\n        E=2\n        S=3\n        W=0\n    \n    #If the robot is facinng South\n    if orientation==180:\n        N=2\n        E=3\n        S=0\n        W=1\n   \n    #If the robot is facing west \n    if orientation==270:\n        N=3\n        E=0\n        S=1\n        W=2\n    return N, E, S, W\n\n#This function allows the robot move around the maze. \n#It detects the angle it is to move due to the walls recorded on the lists\n#It accepts 2 arguments. If scan is true, new values are accepted into the tiles list\n#Target selects the list in which it's going to be applied\ndef check_wall_on_left(scan=True, target=0):\n    \n    #Determines what list to read from \n    #The list of tiles on the path from the position of the robot to the finish line. This is called to travel the shortest path \n    if target == 'robot':\n        global robot\n        tiles = robot\n    else:\n        #This list is used to explore the maze\n        global tiles_list\n        tiles = tiles_list\n    \n    step = 250 #The size of a tile \n    tile_num = num_predictor(location.position(X, MM), location.position(Y, MM))#The tile number is determined by the position of the robot \n    \n    #Determining the index of the list tile relative to the robot\n    N, E, S, W = frame()\n    if scan:\n        wall_mapping()\n\n    #If it has been at the tile twice. This is to allow for an island in the maze to be recorded\n    #An island is a part of a maze that is disconnected from the sides of the it.\n    if tiles[int(tile_num/10)][tile_num % 10][1] == 2:\n        #If the East tile has still not being recorded it turns right and records it. \n        if tiles[int(tile_num/10)][tile_num % 10][0][E] == 'u':\n            \n            terminator(RIGHT, 90, scan)\n\n            if scan:\n                wall_mapping()\n            \n            terminator(LEFT, 90, scan)\n\n    #Checks if it has recoreded there is no wall on the left of the robot\n    if (tiles[int(tile_num/10)][tile_num % 10][0][W]==0):\n        terminator(LEFT, 90, scan)\n\n    else:\n    #Checks if it has recorded a wall to the left of the robot\n        if (tiles[int(tile_num/10)][tile_num % 10][0][W]==1):\n            if (tiles[int(tile_num/10)][tile_num % 10][0][N]==1):\n                if (tiles[int(tile_num/10)][tile_num % 10][0][E]==1):\n                    #Detected a wall to the left, ahead and to the right of the robot\n                    Angle=180\n                else:\n                    #Detected a wall to the left and ahead relative to the robot\n                    Angle=-90\n            else:\n                #Detected a wall to the left relative to the robot\n                Angle=0\n        else:\n            #There is no wall detected to the left \n            if (tiles[int(tile_num/10)][tile_num % 10][0][W]==0):\n                Angle = 90\n            else:\n                #There is no recording of a wall\n                terminator(LEFT, 60, scan)\n                \n                #It detects a wall to the left \n                if distance.get_distance(MM)<=80:\n                    #It records the wall \n                    if scan:\n                        tiles_list[int(tile_num/10)][tile_num % 10][0][W] = 1\n                        adjacent_filler(tile_num, 1, orientation=W)\n\n                    Angle = -60\n                #It detects there is no wall to the left \n                else:\n                    Angle = 30\n    \n            \n        #Rotate the robot given the appropriate angle \n        terminator(LEFT, Angle, scan)\n    \n        \n        #Record wall or not\n        if scan:\n            wall_mapping()\n\n        #If there is a wall infront of it, it will keep on rotating to the right until there is no wall. It scans and records every 90 degrees \n        while distance.get_distance(MM)<step:\n            wait(5, MSEC)\n            terminator(RIGHT, 90, scan)\n            #record\n            if scan:\n                wall_mapping()\n\n    if scan:\n        wall_mapping()\n    \n    #The robot is facing the direction where it is moving to the next tile \n    #North direction relative to the direction of the robot is used to determine the next tile number\n    N, E, S, W = frame()\n    if N == 0:\n        tile_num += 10 #moving North \n    elif N == 1:\n        tile_num += 1 #moving East \n    elif N == 2:\n        tile_num -= 10 #moving South \n    elif N == 3:\n        tile_num -= 1 #moving West\n\n    #It keeps track of the amount of tiles it has been on the tile\n    count = 1\n    tiles[int(tile_num/10)][tile_num%10][1] += 1\n    \n    #Keep going forward until it has to turn\n    while(tiles[int(tile_num/10)][tile_num % 10][0][W]==1 and tiles[int(tile_num/10)][tile_num % 10][0][N]==0) and not (tiles[int(tile_num/10)][tile_num % 10][1] == 2 and tiles[int(tile_num/10)][tile_num % 10][0][E] == 'u'):\n       \n        wait(1, MSEC)\n        #Add a count per tile that doesn't need a turn\n        count += 1\n        if N == 0:\n            tile_num += 10\n        elif N == 1:\n            tile_num += 1\n        elif N == 2:\n            tile_num -= 10\n        elif N == 3:\n            tile_num -= 1\n        tiles[int(tile_num/10)][tile_num%10][1] += 1\n        \n    #Drive as many steps as counts\n    drivetrain.drive_for(FORWARD, step*count, MM)\n\n#This function displays the map. \n#Each tile is represented by 2 by 2 squares I MEAN. two rows of tiles\n#For each row of tiles it has to print out two colored square for each tile and two rows of tiles.\n#The north and west walls of each tile is only taken into concideration. \n#The black square represents the walls in the maze. White, yellow, orange, blue squares represent tiles.\n#target specifies at which list is being displayed\ndef display_map(target=0):\n    \n    #read in the list tiles\n    if target== 0:\n        global tiles_list\n        tiles = tiles_list\n    elif target == 'start':\n        global starting\n        tiles = starting\n    elif target == 'robot':\n        global robot\n        tiles = robot\n    \n    #Starting from the left top corner and working down each row from 70 to 0 \n    #initialising the row \n    ten=7\n    #for the diffence rows of tiles\n    for j in range (8):\n       \n        #initialising the column \n        row = 1\n        \n        # For each tile number it has to print out two square and two rows of each row of tile number \n        for i in range (2):\n            \n            #For the diffence rows of tiles starting with 0 to 77\n            for unit in range(8):\n                \n                if (row==2) and (ten==0) and (unit==4):\n                    \n                    #The starting tile \n                    if tiles[ten][unit][0][3]==1:\n                        brain.print('â¬›ðŸŸ©')\n                    else:\n                        Color_tile(ten,unit,row,1)\n                        brain.print('ðŸŸ©')\n                else:\n                    #All the sides of the walls are closed \n                    if (tiles[ten][unit][0][0]==1)and (tiles[ten][unit][0][1]==1)and (tiles[ten][unit][0][2]==1)and (tiles[ten][unit][0][3]==1):\n                        brain.print('â¬›â¬›')\n                    else:\n                        #The north wall is closed  \n                        if tiles[ten][unit][0][0]==1:\n                            \n                            if row ==1:\n                                #It is at the finish line wall\n                                if (ten==7)and (unit==3):\n                                    brain.print('â¬›ðŸ”š')\n                                else:\n                                    brain.print('â¬›â¬›')\n                            else :\n                                #It is at the finish line tile \n                                if (ten==7)and (unit==3):\n                                    if tiles[ten][unit][0][3]==1:\n                                        brain.print('â¬›ðŸŸ¥')\n                                    else:\n                                        Color_tile(ten,unit,row,1)\n                                        brain.print('ðŸŸ¥')\n                                else:\n                                    #There is a wall to the West and wall to the North of the tile \n                                    if tiles[ten][unit][0][3]==1:\n                                        brain.print('â¬›')\n                                        Color_tile(ten,unit,row,2)\n    \n                                    else:\n                                        #There is only a wall to the North of the tile \n                                        Color_tile(ten,unit,row,1)\n                                        Color_tile(ten,unit,row,2)\n                                        \n                        #There is only a wall to the West of the tile\n                        elif tiles[ten][unit][0][3]==1:\n                            brain.print('â¬›')\n                            Color_tile(ten,unit,row,2)\n                        \n                        #When there is a wall to the East of the tile ahead of the tile it is displaying or there is a wall to the north of the tile that is to the left of the tile it is displaying.\n                        elif (tiles[ten+1][unit][0][3]==1)or(tiles[ten][unit-1][0][0]):\n                            if row==1:\n                                brain.print('â¬›')\n                                Color_tile(ten,unit,row,2)\n                            else :\n                                Color_tile(ten,unit,row,1)\n                                Color_tile(ten,unit,row,2)\n                        \n                        #There is no wall to the North or West of the tile \n                        else:\n\n                            Color_tile(ten,unit,row,1)\n                            Color_tile(ten,unit,row,1)\n            \n            #This prints the outside East wall that surrounds the map and moves to the next row \n            brain.print('â¬›')\n            brain.print('\\n')\n            row = row+1 \n        ten= ten-1\n    \n    #prints the outside South wall that surrounds the map\n    for p in range (17):\n        #Prints out the starting tile wall \n        if (p==9):\n            brain.print('ðŸŸ©')\n        else:\n        \n            brain.print('â¬›')\n\n#Each tile is broke up into a 2 by 2 squares, each square is displayed individually \n#The function is responisible for displaying the tiles\n#This function is given the the tile number it is displaying, the row of the squre and the column of the square. \n#It looks through a specific list and assigns the approciate colour square to reprsent the tile.\n#If it is displaying the map without displaying any paths it assigns a white square \n#It assigns a blue square to represent the path from the starting line to the finish line,\n#an orange tile to represent the path of the robot initial position to the final line, and a yellow square to represent the\n#joint path. It prints the square to the screen\ndef Color_tile(ten_p,unit_p,row,order):\n\n    global starting\n    global robot\n    global count_distance_starting\n    global count_distance_robot\n\n    #It first needs to find which tile numbers are on the different list \n    starting_number=[] #keeps the list of tile numbers on the path from the starting position to the final position \n    robot_number=[] #keeps the list of tile numbers on the path from the robots initial position to the final position\n    \n    #It checks if it has recorded all the tiles in the maze\n    total_length_start = sum(len(row) for row in starting) \n    total_length_robot = sum(len(row) for row in robot)\n\n    #If it has recorded all the walls in the maze then it prints out the appropriate path.\n    if(total_length_start == 64) and (total_length_robot==64) :\n        #Determines what path it is on \n        color_s=0  \n        color_r=0\n        \n        #Checks how many walls are closed \n        count_wall_starting=0\n        count_wall_robot=0\n    \n        for index in range(4):\n            if starting[ten_p][unit_p][0][index]==1:\n                count_wall_starting=count_wall_starting+1\n                \n            if (robot[ten_p][unit_p][0][index])==1:\n                count_wall_robot=count_wall_robot+1\n                \n            wait(1,MSEC)\n\n        #For the square in the top right corner it checks the tile to the north to see if it is on the list aswell \n        if row ==1 and order==2:\n            \n            count_wall_starting_adj=0\n            count_wall_robot_adj=0\n    \n            for index in range(4):\n                if starting[ten_p+1][unit_p][0][index]==1:\n                    count_wall_starting_adj=count_wall_starting_adj+1\n                    \n                if (robot[ten_p+1][unit_p][0][index])==1:\n                    count_wall_robot_adj=count_wall_robot_adj+1\n                \n                wait(1,MSEC)\n            #The tile to the north is neither on both list therefore it should display a white tile \n            if count_wall_starting_adj==4 and  count_wall_robot_adj==4:\n                return brain.print(\"â¬œ\")\n        #For the square in the bottom left corner it checks the tile to the north to see if it is on the list as well\n        if row ==2 and order ==1:\n            \n            count_wall_starting_adj=0\n            count_wall_robot_adj=0\n    \n            for index in range(4):\n                if starting[ten_p][unit_p-1][0][index]==1:\n                    count_wall_starting_adj=count_wall_starting_adj+1\n                   \n                if (robot[ten_p][unit_p-1][0][index])==1:\n                    count_wall_robot_adj=count_wall_robot_adj+1\n               \n                wait(1,MSEC)\n            #The tile to the left is neither on both list therefore it should displays a white tile \n            if count_wall_starting_adj==4 and count_wall_robot_adj==4:\n                return brain.print(\"â¬œ\")\n        \n        #If all the four walls are not closed it is on the starting position to the finish position  \n        if count_wall_starting is not 4 :\n            color_s=1\n        #If all the four walls are not closed it is on the robots initial position to the finish position\n        if count_wall_robot is not 4  :\n            color_r=1\n\n        if color_s==1 and color_r==1:\n            brain.print(\"ðŸŸ¨\")  #joint path\n            count_distance_starting = 1 + count_distance_starting\n            count_distance_robot = 1 + count_distance_robot\n        elif color_s==1:\n            brain.print(\"ðŸŸ¦\") #starting position-finish line \n            count_distance_starting = 1 + count_distance_starting\n        elif color_r==1:\n            brain.print(\"ðŸŸ§\") #robots position-finish line \n            count_distance_robot = 1 + count_distance_robot\n        else:\n            brain.print(\"â¬œ\") #not on the path \n    else:\n        brain.print(\"â¬œ\") #Printing out normal maze with no paths \n\n#Checks for dead ends, which are tiles with 3 walls, which means it looks for a tile with\n#3 ones. returns true if it's a dead end and the orientation of the opening\ndef dead_end_checker(tile):\n\n    count = 0\n    for wall in range(len(tile)):\n        if tile[wall] == 1:\n            count += 1\n        else:\n            orientation = wall\n    if count == 3:\n        return [True, orientation]\n    else:\n        return [False, 'u']\n\n#Solves the maze. It looks for all the dead ends and close them. That converts the next tile into a dead end\n#That one will be close again until it gets to a joint (only 1 wall). It is an intersection. After looping\n#through all the tiles, only the ones that are part of the solution will remain open (without four 1s\n#on them). Target specifies to which list it should be applied and what is the starting point, either the\n#starting tile (4) or the current position of the robot\ndef solver(target):\n  if target == 'start':\n      global starting\n      tiles = starting\n      end = 4\n  else:\n      global robot\n      tiles = robot\n      end = num_predictor(location.position(X, MM), location.position(Y, MM))\n  # global tiles\n  while True:\n      wait(5,MSEC)\n      dead = 0\n      for row in range(8):\n          for tile in range(8):\n              tile_dead = dead_end_checker(tiles[row][tile][0])\n              if tile_dead[0] and row*10+tile != 73 and row*10+tile != end:\n                  tiles[row][tile][0] = [1, 1, 1, 1]\n                  adjacent_filler(row*10+tile, 1, tile_dead[1], target)\n                  dead += 1\n      if dead == 0:\n          break\n\n#This solves for any squares in the maze. It puts all the walls in open tiles that make a square to 1\n#It can also be applied to different lists through target\ndef square_solver(target):\n    if target == 'start':\n        global starting\n        tiles = starting\n    else:\n        global robot\n        tiles = robot\n    for row in range(8):\n        for col in range(8):\n            current_tile = row*10+col\n            count = 0\n            holes = 0  #Number of holes in the tile           \n            for i in range(4):\n                wait(1, MSEC)\n                #Change the reference frame\n                N, E, S, W = frame(i*90)\n                total_walls = 0\n                for wall in tiles[int(current_tile/10)][current_tile%10][0]:\n                    total_walls += wall\n                if total_walls > 2:\n                    holes = 0\n                    break\n                #Check if it has an opening at the right positions\n                if (tiles[int(current_tile/10)][current_tile%10][0][N] == 1 and tiles[int(current_tile/10)][current_tile%10][0][W] == 0) or (tiles[int(current_tile/10)][current_tile%10][0][N] == 0 and tiles[int(current_tile/10)][current_tile%10][0][W] == 1):\n                    opened = current_tile\n                    holes += 1\n                    if holes == 2:\n                        break\n                #If it has 2 openings, leave the loop\n                elif tiles[int(current_tile/10)][current_tile%10][0][N] == 0 and tiles[int(current_tile/10)][current_tile%10][0][W] == 0:\n                    holes = 2\n                    break\n                \n                #Turn on the square counterclockwise and starting from the left lower corner\n                if i == 0 and current_tile%10<7:\n                    current_tile += 1\n                elif i == 1 and current_tile>10:\n                    current_tile -= 10\n                elif i == 2:\n                    current_tile -= 1\n                elif i == 3:\n                    current_tile += 10\n            \n            #If there is 1 hole, close all the walls on it\n            if holes == 1:\n                tiles[int(opened/10)][opened%10][0] = [1, 1, 1, 1]\n                adjacent_filler(opened, 1, 0, target)\n                adjacent_filler(opened, 1, 1, target)\n                adjacent_filler(opened, 1, 2, target)\n                adjacent_filler(opened, 1, 3, target)\n\n#This function counts the amount of walls in a tile. It accepts the tile number and the list to work with\ndef wall_count(num, target):\n    if target == 'start':\n        global starting\n        tiles = starting\n\n    elif target == 'robot':\n        global robot\n        tiles = robot\n\n    else:\n        global tiles_list\n        tiles = tiles_list\n    count = 0\n    walls = tiles[int(num/10)][num%10][0]\n    for wall in walls:\n        count += wall\n    return count\n\n#Gets rid of all the paths that are too long and leaves the shortest path\ndef path_finder(target):\n    if target == 'start':\n        global starting\n        tiles = starting\n    elif target=='robot':\n        global robot\n        tiles = robot\n    \n    global paths\n    #Intersection. These are all the tiles with 1 wall.\n    #If there is more than one valid path, at some point they will join at an intersection \n    inter = []\n    \n    for row in range(8):\n        for tile in range(8):\n            count = 0\n            for wall in range(len(tiles[row][tile][0])):\n                wait(1, MSEC)\n                count += tiles[row][tile][0][wall]\n    \n            if count == 1:\n                inter.append(row*10+tile)\n\n\n    #Keep looping while there is at least one intersection to check\n    while len(inter) != 0:\n\n        wait(5, MSEC)\n        tile_num = inter[0]\n    \n        for wall in range(4):\n            tile_num = inter[0]\n            walls = tiles[int(tile_num/10)][tile_num%10][0]\n            path = []\n            #Take the first open wall\n            if walls[wall] == 0:\n                orientation = wall\n    \n                #Moves to the second tile\n                if orientation == 0:\n                    tile_num += 10\n                    orientation = 2\n                    \n                elif orientation == 1:\n                    tile_num += 1\n                    orientation = 3\n    \n                elif orientation == 2:\n                    tile_num -= 10\n                    orientation = 0\n    \n                elif orientation == 3:\n                    tile_num -= 1\n                    orientation = 1\n\n                wall_c = wall_count(tile_num, target)\n    \n    \n                path.append(tile_num)\n                current_tile = num_predictor(location.position(X, MM), location.position(Y, MM))\n                #Keep walking through the path until it gets to another intersection, to the robot\n                #Or to a dead end, which after being solved before, this may only happen at the end or\n                #the start of the maze\n                while wall_c == 2 and current_tile != tile_num:\n                    wait(1, MSEC)\n                    wall_c = 3\n    \n                    indeces = list(range(4))\n                    #Take out of the list the wall that is opened\n                    indeces.pop(orientation)\n                    walls = tiles[int(tile_num/10)][tile_num%10][0]\n    \n                    #Change the index\n                    for index in indeces:\n                        if walls[index] == 0:\n                            orientation = index\n    \n                    #Moves to the next tile\n                    if orientation == 0:\n                        tile_num += 10\n                        orientation = 2\n                        \n                    elif orientation == 1:\n                        tile_num += 1\n                        orientation = 3\n    \n                    elif orientation == 2:\n                        tile_num -= 10\n                        orientation = 0\n    \n                    elif orientation == 3:\n                        tile_num -= 1\n                        orientation = 1\n    \n                    wall_c = wall_count(tile_num, target)\n    \n    \n                    path.append(tile_num)\n    \n                paths.append(path)\n\n        #Delete the current intersection from the list\n        del inter[0]\n\n    if target == 'start':\n        start_tile = 4\n    else:\n        start_tile = num_predictor(location.position(X, MM), location.position(Y, MM))\n    \n    #If a path ends in the ending, the starting tile or the position of the robot, delete it from the list\n    for path in range(len(paths)):\n        if (paths[path][-1] == 73 or paths[path][-1] == start_tile):\n            paths[path] = ''\n    \n    while '' in paths:\n        wait(5, MSEC)\n        paths.remove('')\n    \n    #Look for the shortes path. It will be the one with less tiles on it\n    min_length = 64  #Set minimum to 64 as there is no path longer than 64 (number of tiles in the maze)\n    min_path = []\n    for path in paths:\n        if min_length > len(path):\n            min_length = len(path)\n\n    \n    #Remove all the paths that have the same length as min_length\n    for path in range(len(paths)):\n        if len(paths[path]) == min_length:\n            paths[path] = ''\n    \n    while '' in paths:\n        paths.remove('')\n    \n    #Close all remaining paths as these are the longer ones\n    for path in paths:\n        for tile in path[:-1]:\n            walls = tiles[int(tile/10)][tile%10][0]\n            for wall in range(len(walls)):\n                if walls[wall] == 0:\n                    adjacent_filler(tile, 1, wall, target)\n    \n            tiles[int(tile/10)][tile%10][0] = [1, 1, 1, 1]\n\n#It returns the coordinates of a tile given it's number\ndef coord_predictor(num):\n    global origin\n    global tile\n    global wall\n\n    a = int(num/10)     #Dividing the number by ten and truncating the result gives the tens\n    b = num % 10        #Modulo of the number gives the units\n\n    x = origin+tile/2+(tile+wall)*b  #The corner of the first tile is at origin+tile/2\n    y = origin+tile/2+(tile+wall)*a\n    return x, y\n\n#It return the coordinates of a point measured by the distance sensor\ndef get_coord():\n    dist = distance.get_distance(MM)\n    if dist < 3000:     #If the distance is greater or equal to 3000 no calculations will be made\n        #The x coordinate of the object can be calculated by multiplying the distance times the\n        #cos of the angle of the robot plus the current x position of the robot\n        #For y is the same but with sin and the y position of the robot\n        #90 must be substracted from the angle as the robot counts a 90Âº angle as a 0Âº angle\n        dist += 72    #72 is the distance from the center of the robot to the distance sensor (measured\n        if drivetrain.heading(DEGREES) < 90:\n            x = dist * abs(math.cos((90 - drivetrain.heading(DEGREES)) * math.pi / 180)) + location.position(X, MM)\n            y = dist * math.sin((90 - drivetrain.heading(DEGREES)) * math.pi / 180) + location.position(Y, MM)\n\n        else:\n            x = dist * math.cos((90 - drivetrain.heading(DEGREES)) * math.pi / 180) + location.position(X, MM)\n            y = dist * math.sin((90 - drivetrain.heading(DEGREES)) * math.pi / 180) + location.position(Y, MM)\n        return [x, y]\n\n#Returns the orientation of the wall that is being measured in a tile\n#It calculates the distance from the center of each wall to the measured point.\n#The lowest distance will be the one of the wall that is being measured\ndef where(tile, coord):\n    x, y = coord_predictor(tile)\n\n    half_tile = 115\n\n    xn, yn = x, y + half_tile\n    xe, ye = x + half_tile, y\n    xs, ys = x, y - half_tile\n    xw, yw = x - half_tile, y\n\n    distances = [math.sqrt((xn-coord[0])**2+(yn-coord[1])**2), math.sqrt((xe-coord[0])**2+(ye-coord[1])**2),\n            math.sqrt((xs-coord[0])**2+(ys-coord[1])**2), math.sqrt((xw-coord[0])**2+(yw-coord[1])**2)]\n\n    dist = min(distances)\n    pos = distances.index(dist)\n\n\n    return pos\n\n#Returns the coordinates of the corners of a tile\ndef corners_tile(num):\n    x1 = origin + (tile + wall) * (num%10)\n    y1 = origin + (tile + wall) * int(num/10)\n\n    x2 = origin + (tile + wall) * (num%10)\n    y2 = origin + (tile + wall) * int(num/10)+tile\n\n    x3 = origin + (tile + wall) * (num%10)+tile\n    y3 = origin + (tile + wall) * int(num/10)\n\n    x4 = origin + (tile + wall) * (num%10)+tile\n    y4 = origin + (tile + wall) * int(num/10)+tile\n\n    return [[x1, y1], [x2, y2], [x3, y3], [x4, y4]]\n\n#Returns true is a point lies within a distance of radius to the corner of a tile.\n#This needs to be done as the walls in vexcode seems to be sticking out from the measuring of the sensor.\n#We can take this as invalid measurements\ndef forbidden(x, y, tile):\n    global forbidden_areas\n\n    radius = 100\n    for corner in forbidden_areas[int(tile/10)][tile%10]:\n        dist = distance_to_corner(x, y, corner)\n        if dist <= radius:\n            return True\n\n    return False\n\n#Get the distance of a point to a corner\ndef distance_to_corner(x, y, corner):\n    dist = math.sqrt((x-corner[0])**2 + (y-corner[1])**2)\n    return dist\n\n#Creates all the coordinates of all the corners of the tiles\ndef init_forbidden():\n    global forbidden_areas\n\n    for row in range(8):\n        forbidden_areas.append([])\n        for col in range(8):\n            tile_num = row*10+col\n            corners = corners_tile(tile_num)\n            forbidden_areas[row].append(corners)\n\n#It gives the angle in positive values depending on whether is needed to turn left or right\ndef current_angle(direction):\n    mes_angle = drivetrain.heading(DEGREES)\n    if direction == RIGHT:\n        angle = mes_angle\n\n    elif direction == LEFT:\n        if mes_angle == 0:\n            angle = 0\n        \n        #Substracting 360 swaps the direction of a positive turn\n        else:\n            angle = 360 - mes_angle\n\n    return angle\n\n\n#This can be use the same was as drivetrain.turn_for, but it will scan and assign values to walls as it\n#turns\ndef terminator(direction, angle, scan):\n    global tiles_list\n    global forbidden_areas\n\n    #If the angle is negative, reverse the direction of turn\n    if angle < 0:\n        angle = abs(angle)\n        if direction == RIGHT:\n            direction = LEFT\n        else:\n            direction = RIGHT\n    \n    #Initial angle\n    init = current_angle(direction)\n   \n    #Calculate angle to turn to\n    if direction == LEFT:\n        objective = init + angle\n\n    elif direction == RIGHT:\n        objective = init + angle\n\n    while objective >= 360:\n        wait(1,MSEC)\n        objective -= 360\n    #Get the current angle according to the direction it needs to turn\n    cur_angle = current_angle(direction)\n\n    drivetrain.turn(direction)\n    #Scan while the angle is in a range of +-25Âº of the objective.\n    #This wide range is needed as vexcode does not update the values of the angles too often.\n    #They are update in a specific time period we think is dependent of the internet connecton speed.\n    #So if the connection is slow enough, the robot will make a 360Âº angle, as it would have skipped\n    #the stopping range\n    while cur_angle < objective-25 or cur_angle > objective+25:\n        wait(1, MSEC)\n        #Only scan if it is required. Needed to navigate through the solution without\n        #overwritting it\n        if scan:\n            coord = get_coord()\n            if coord != None:\n                x, y = coord\n                tile_num = num_predictor(x, y)\n                status = forbidden(x, y, tile_num)  #True if it's too close to a corner\n                #A max disamestance to measure was needed. When the robot was not perpendicular to the wall\n                #It was not accurate enough to get a reliable calculation\n                #The more parallel it is to the wall it's measuring, the less accurate the measurement\n                #gets.\n                if (status == False and distance.get_distance(MM) < 630):\n                    pos = where(tile_num, [x, y])\n                    tiles_list[int(tile_num/10)][tile_num%10][0][pos] = 1\n                    adjacent_filler(tile_num, 1, orientation=pos)\n\n        cur_angle = current_angle(direction)\n\n    drivetrain.stop()\n    wait(100, MSEC)\n    cur_angle = current_angle(direction)\n    while cur_angle != objective:\n        drivetrain.turn_for(direction, objective-cur_angle, DEGREES)\n        cur_angle = current_angle(direction)\n\n#Steps to be taken to solve a maze in a list\ndef solve_maze(target):\n    #Solve for dead ends\n    solver(target)\n    #Solve any squares\n    square_solver(target)\n    #Take out the longer paths\n    path_finder(target)\n    #Take remaining dead ends from previous operations\n    solver(target)\n\ndef main():\n    wait(2, SECONDS)\n    global tiles_list\n    tiles = tiles_list\n    global paths\n\n    drivetrain.set_turn_velocity(100, PERCENT)\n    drivetrain.set_drive_velocity(100, PERCENT)\n\n    global starting\n    global robot\n    global count_distance_starting \n    global count_distance_robot \n    monitor_variable('tiles_list')\n    monitor_variable('starting')\n    monitor_variable('robot')\n    monitor_variable('paths')\n\n    #Initiate tiles and corners of the tiles\n    init_tiles()\n    init_forbidden()\n\n    #Navigate through the maze and scan all the walls\n    mad_eye_strategy()\n\n    brain.print('\\n\\n')\n\n    #Solve the maze from the starting position and from the robot's position\n    solve_maze('start')\n    solve_maze('robot')\n\n    #Display the solution are you tryin to calculate how many spaces we need?\n    brain.print('             TRIWIZARD MAZE\\n' )\n    display_map()\n    brain.print('\\n')\n    brain.print('\\n Lengend \\n ðŸŸ¨ From starting line-finish line and robot position-finish line path \\n ðŸŸ¦ From starting line to finish line path\\n ðŸŸ§ From robot position to finish line path\\n â¬œ Tiles that are not on the paths\\n')\n    brain.print('\\n')\n    time = brain.timer_time(SECONDS)\n    brain.print(f'ðŸ† WE FOUND THE TRIWIZARD CUP IN {int(time/60)}:{round(time%60)} ðŸ†')\n    brain.print(f'\\n\\nShortest distance from the start to the end: {round((count_distance_starting)*125)} mm \\nShortest distance from the robot initial position to the end: {round((count_distance_robot)*125)} mm \\n')\n    #Drive through the solution\n    beat_it()\n\nvr_thread(main())","textLanguage":"python","rconfig":[],"slot":0,"platform":"PG","sdkVersion":"","appVersion":"","fileFormat":"1.0.0","icon":"","playground":"DynamicWallMaze"}